import { Schema, ExportOptions, ValidationError, SchemaField } from '@/types/schema';

export function exportSchema(schema: Schema, options: ExportOptions): string {
  const cleanSchema = { ...schema };
  
  if (!options.includePresets) {
    delete cleanSchema.presets;
    delete cleanSchema.default;
  }
  
  if (!options.includeBlocks) {
    delete cleanSchema.blocks;
  }

  if (options.format === 'json') {
    return options.minify 
      ? JSON.stringify(cleanSchema)
      : JSON.stringify(cleanSchema, null, 2);
  }

  // Liquid format
  return generateLiquidSchema(cleanSchema, options);
}

export function importSchema(content: string): Schema {
  try {
    return JSON.parse(content);
  } catch (error) {
    throw new Error('Invalid JSON format');
  }
}

export function validateSchema(schema: Schema): ValidationError[] {
  const errors: ValidationError[] = [];

  // Validate schema name
  if (!schema.name || schema.name.trim() === '') {
    errors.push({
      field: 'name',
      message: 'Schema name is required',
      type: 'error'
    });
  }

  // Validate settings
  schema.settings.forEach((field, index) => {
    if (!field.id || field.id.trim() === '') {
      errors.push({
        field: `settings[${index}].id`,
        message: 'Field ID is required',
        type: 'error'
      });
    }

    if (!field.label || field.label.trim() === '') {
      errors.push({
        field: `settings[${index}].label`,
        message: 'Field label is required',
        type: 'error'
      });
    }

    // Check for duplicate IDs
    const duplicateIndex = schema.settings.findIndex((f, i) => 
      i !== index && f.id === field.id
    );
    if (duplicateIndex !== -1) {
      errors.push({
        field: `settings[${index}].id`,
        message: 'Duplicate field ID',
        type: 'error'
      });
    }

    // Validate field-specific requirements
    validateField(field, `settings[${index}]`, errors);
  });

  // Validate blocks
  if (schema.blocks) {
    schema.blocks.forEach((block, index) => {
      if (!block.type || block.type.trim() === '') {
        errors.push({
          field: `blocks[${index}].type`,
          message: 'Block type is required',
          type: 'error'
        });
      }

      if (!block.name || block.name.trim() === '') {
        errors.push({
          field: `blocks[${index}].name`,
          message: 'Block name is required',
          type: 'error'
        });
      }
    });
  }

  return errors;
}

function validateField(field: SchemaField, path: string, errors: ValidationError[]) {
  // Validate range field
  if (field.type === 'range') {
    if (field.min === undefined || field.max === undefined) {
      errors.push({
        field: `${path}.min_max`,
        message: 'Range fields require min and max values',
        type: 'error'
      });
    }
  }

  // Validate select/radio fields
  if (['select', 'radio'].includes(field.type)) {
    if (!field.options || field.options.length === 0) {
      errors.push({
        field: `${path}.options`,
        message: 'Select/Radio fields require options',
        type: 'error'
      });
    }
  }

  // Validate number field
  if (field.type === 'number') {
    if (field.step !== undefined && field.step <= 0) {
      errors.push({
        field: `${path}.step`,
        message: 'Step value must be greater than 0',
        type: 'warning'
      });
    }
  }
}

function generateLiquidSchema(schema: Schema, options: ExportOptions): string {
  let output = '';
  
  if (options.includeComments) {
    output += `{% comment %}\n  Schema for ${schema.name}\n  Generated by Shopify Schema Generator\n{% endcomment %}\n\n`;
  }

  output += `{% schema %}\n${JSON.stringify(schema, null, 2)}\n{% endschema %}`;
  
  return output;
}

export function generateFieldId(label: string): string {
  return label
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .replace(/\s+/g, '_')
    .substring(0, 50);
}

export function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}

export function copyToClipboard(text: string): Promise<void> {
  if (navigator.clipboard) {
    return navigator.clipboard.writeText(text);
  }
  
  // Fallback for older browsers
  const textArea = document.createElement('textarea');
  textArea.value = text;
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();
  
  try {
    document.execCommand('copy');
    document.body.removeChild(textArea);
    return Promise.resolve();
  } catch (err) {
    document.body.removeChild(textArea);
    return Promise.reject(err);
  }
} 